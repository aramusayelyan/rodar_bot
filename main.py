import os
import re
import logging
import asyncio
from telegram import Update, ReplyKeyboardMarkup, KeyboardButton
from telegram.ext import Application, CommandHandler, MessageHandler, CallbackQueryHandler, ConversationHandler, ContextTypes, filters

# ’ø’•’≤’°’Ø’°’∂ ’¥’∏’§’∏÷Ç’¨’∂’•÷Ä
import scraper
import keyboards
import config

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Define conversation states
SELECT_PHONE, ENTER_CODE, SELECT_DEPT, SELECT_EXAM, SELECT_SEARCH, ENTER_INFO = range(6)

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Start command handler: greet user and ask for phone number (allow sharing contact)."""
    user = update.effective_user
    # Greeting message
    await update.message.reply_text(
        f"‘≤’°÷Ä’•÷Ç’õ {user.first_name if user.first_name else '÷Ö’£’ø’°’£’∏÷Ä’Æ’∏’≤'}÷â\n"
        "‘±’µ’Ω ’¢’∏’ø’´ ÷Ö’£’∂’∏÷Ç’©’µ’°’¥’¢ ‘¥’∏÷Ç÷Ñ ’Ø’°÷Ä’∏’≤ ’•÷Ñ ’∞’•÷Ä’©’°’£÷Ä’æ’•’¨ ’É’°’∂’°’∫’°÷Ä’∞’°’µ’´’∂ ’∏’Ω’ø’´’Ø’°’∂’∏÷Ç’©’µ’∏÷Ç’∂’∏÷Ç’¥ ’æ’°÷Ä’∏÷Ä’§’°’Ø’°’∂ ÷Ñ’∂’∂’∏÷Ç’©’µ’°’∂ ’∞’°’¥’°÷Ä÷â\n"
        "‘Ω’∂’§÷Ä’∏÷Ç’¥ ’•’¥ ’∏÷Ç’≤’°÷Ä’Ø’•’¨ ’Å’•÷Ä ’∞’•’º’°’≠’∏’Ω’°’∞’°’¥’°÷Ä’® (’Ø’°’¥ ’Ω’•’≤’¥’•’¨ ’Ø’∏’≥’°’Ø’®’ù ’∞’°’¥’°÷Ä’∏’æ ’Ø’´’Ω’æ’•’¨’∏÷Ç ’∞’°’¥’°÷Ä)÷â\n\n"
        "‘≥’∏÷Ä’Æ’∏’≤’∏÷Ç’©’µ’∏÷Ç’∂’´÷Å ’§’∏÷Ç÷Ä’Ω ’£’°’¨’∏÷Ç ’∞’°’¥’°÷Ä ’∏÷Ç’≤’°÷Ä’Ø’•÷Ñ /cancel ’∞’°÷Ä’¶’°’∂’´’∑’®÷â",
        reply_markup=keyboards.phone_request_keyboard()
    )
    return SELECT_PHONE

async def receive_phone(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle phone number input (either as shared contact or text). Initiate login via Selenium (send SMS code)."""
    if update.message.contact:
        # If user shared contact
        phone = update.message.contact.phone_number
    else:
        phone = update.message.text.strip()
    # Keep only digits, remove '+' and spaces
    phone_digits = re.sub(r"\D", "", phone)
    # Remove country code if present (assume +374 for Armenia)
    if phone_digits.startswith("374"):
        phone_digits = phone_digits[3:]
    logger.info(f"Received phone: {phone_digits}")
    # Initiate Selenium: open site and send SMS code
    try:
        driver = await asyncio.get_running_loop().run_in_executor(
            None, scraper.login_start, phone_digits
        )
    except Exception as e:
        logger.error(f"Selenium login_start error: {e}")
        await update.message.reply_text("‘Ω’∂’§÷Ä’∏÷Ç’¥ ’•’∂÷Ñ ‡§ï‡•ç‡§∑’¥’•’¨, ’≠’∂’§’´÷Ä ’°’º’°’ª’°÷Å’°’æ ’¢’∏’ø’´ ’°’∑’≠’°’ø’°’∂÷Ñ’∏÷Ç’¥÷â ’ì’∏÷Ä’±’•÷Ñ ’Ø÷Ä’Ø’´’∂÷â")
        return ConversationHandler.END
    # Store the Selenium WebDriver instance for later steps
    context.user_data["driver"] = driver
    # Ask for OTP code
    await update.message.reply_text("‘Ω’∂’§÷Ä’∏÷Ç’¥ ’•’∂÷Ñ ’¥’∏÷Ç’ø÷Ñ’°’£÷Ä’•’¨ SMS-’∏’æ ’Ω’ø’°÷Å’°’Æ ’∞’°’Ω’ø’°’ø’¥’°’∂ ’Ø’∏’§’®÷â")
    return ENTER_CODE

async def receive_code(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle SMS code input. Verify login and proceed to department selection."""
    code = update.message.text.strip()
    driver = context.user_data.get("driver")
    if not driver:
        await update.message.reply_text("’Ü’•÷Ä’∏’≤’∏÷Ç’©’µ’∏÷Ç’∂, ’ø’•’≠’∂’´’Ø’°’Ø’°’∂ ’≠’∂’§’´÷Ä ’°’º’°’ª’°÷Å’°’æ÷â ’ì’∏÷Ä’±’•÷Ñ ’Ω’Ø’Ω’•’¨’∏÷Ç÷Å /start÷â")
        return ConversationHandler.END
    # Verify OTP code via Selenium
    try:
        success = await asyncio.get_running_loop().run_in_executor(
            None, scraper.login_verify, driver, code
        )
    except Exception as e:
        logger.error(f"Selenium login_verify error: {e}")
        await update.message.reply_text("‘ø’°’µ÷Ñ’´÷Å ’ø’æ’µ’°’¨’∂’•÷Ä ’æ’•÷Ä÷Å’∂’•’¨’∏÷Ç ’®’∂’©’°÷Å÷Ñ’∏÷Ç’¥ ’Ω’≠’°’¨ ’ø’•’≤’´ ’∏÷Ç’∂’•÷Å’°’æ÷â ’ì’∏÷Ä’±’•÷Ñ ’∂’∏÷Ä’´÷Å /start ’∞÷Ä’°’¥’°’∂’∏’æ÷â")
        # Cleanup driver
        driver.quit()
        return ConversationHandler.END
    if not success:
        # Wrong code, ask again
        await update.message.reply_text("’Ñ’∏÷Ç’ø÷Ñ’°’£÷Ä’°’Æ ’Ø’∏’§’® ’Ω’≠’°’¨ ’ß÷â ‘Ω’∂’§÷Ä’∏÷Ç’¥ ’•’∂÷Ñ ÷É’∏÷Ä’±’•’¨ ’Ø÷Ä’Ø’´’∂‚Ä§")
        return ENTER_CODE
    # If login successful, retrieve list of departments
    try:
        dept_list = scraper.get_departments(driver)
    except Exception as e:
        logger.error(f"Error fetching departments: {e}")
        await update.message.reply_text("’â’∞’°’ª’∏’≤’æ’•÷Å ’Ω’ø’°’∂’°’¨ ’¢’°’™’´’∂’∂’•÷Ä’´ ÷Å’°’∂’Ø’®÷â ’ì’∏÷Ä’±’•÷Ñ ’Ø÷Ä’Ø’´’∂ /start ’Ω’Ø’Ω’•’¨÷â")
        driver.quit()
        return ConversationHandler.END
    # Ask user to choose department (inline keyboard)
    await update.message.reply_text(
        "‘∏’∂’ø÷Ä’•÷Ñ ’∞’°’∑’æ’°’º’¥’°’∂-÷Ñ’∂’∂’°’Ø’°’∂ ’¢’°’™’´’∂’®‚Ä§",
        reply_markup=keyboards.department_keyboard(dept_list)
    )
    return SELECT_DEPT

async def choose_department(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle department selection via inline button."""
    query = update.callback_query
    await query.answer()  # acknowledge callback
    data = query.data  # e.g. "dept:123"
    if not data.startswith("dept:"):
        return SELECT_DEPT  # ignore unexpected data
    dept_value = data.split(":", 1)[1]
    dept_name = next((name for name, val in context.user_data.get("departments_list", []) if val == dept_value), None)
    context.user_data["department"] = dept_value
    context.user_data["department_name"] = dept_name
    # Ask for exam type
    await query.edit_message_text(
        text=f"‘∏’∂’ø÷Ä’æ’°’Æ ’¢’°’™’´’∂’ù {dept_name}÷â\n‘Ω’∂’§÷Ä’∏÷Ç’¥ ’•’∂÷Ñ ’®’∂’ø÷Ä’•’¨ ÷Ñ’∂’∂’∏÷Ç’©’µ’°’∂ ’ø’•’Ω’°’Ø’®‚Ä§",
        reply_markup=keyboards.exam_type_keyboard()
    )
    return SELECT_EXAM

async def choose_exam_type(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle exam type selection via inline button."""
    query = update.callback_query
    await query.answer()
    exam_type = query.data  # "theoretical" or "practical"
    if exam_type not in ("theoretical", "practical"):
        return SELECT_EXAM
    context.user_data["exam_type"] = exam_type
    # Human-readable exam name for user feedback
    exam_label = "’è’•’Ω’°’Ø’°’∂" if exam_type == "theoretical" else "‘≥’∏÷Ä’Æ’∂’°’Ø’°’∂"
    # Ask for search method
    await query.edit_message_text(
        text=f"‘∏’∂’ø÷Ä’æ’°’Æ ÷Ñ’∂’∂’∏÷Ç’©’µ’°’∂ ’ø’•’Ω’°’Ø’ù {exam_label}÷â\n‘∏’∂’ø÷Ä’•÷Ñ ’∏÷Ä’∏’∂’¥’°’∂ ’±÷á’® (÷Ö÷Ä, ’°’¥’Ω’°’©’´’æ ’Ø’°’¥ ’™’°’¥)‚Ä§",
        reply_markup=keyboards.search_method_keyboard()
    )
    return SELECT_SEARCH

async def choose_search_method(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle search method (day/date/time) selection via inline button."""
    query = update.callback_query
    await query.answer()
    method = query.data  # "day", "date", or "time"
    if method not in ("day", "date", "time"):
        return SELECT_SEARCH
    context.user_data["search_mode"] = method
    if method == "day":
        # Search for earliest available slot (no additional input needed)
        await query.edit_message_text("üîÑ ‘Ω’∂’§÷Ä’∏÷Ç’¥ ’•’∂÷Ñ ’Ω’∫’°’Ω’•’¨, ’Ø’°’ø’°÷Ä’æ’∏÷Ç’¥ ’ß ’∏÷Ä’∏’∂’∏÷Ç’¥...")
        driver = context.user_data.get("driver")
        branch_val = context.user_data.get("department")
        exam_type = context.user_data.get("exam_type")
        try:
            result_text = await asyncio.get_running_loop().run_in_executor(
                None, scraper.search_slots, driver, branch_val, exam_type, "day", None
            )
        except Exception as e:
            logger.error(f"Error searching slots: {e}")
            result_text = "’Ü’•÷Ä’∏’≤’∏÷Ç’©’µ’∏÷Ç’∂, ’∏÷Ä’∏’∂’∏÷Ç’¥’® ’±’°’≠’∏’≤’æ’•÷Å÷â ’ì’∏÷Ä’±’•÷Ñ ’Ø÷Ä’Ø’´’∂÷â"
        # Send the result to user
        await query.edit_message_text(result_text)
        # Cleanup Selenium driver
        if driver:
            driver.quit()
        return ConversationHandler.END
    elif method == "date":
        # Ask user to input a specific date
        await query.edit_message_text("‘Ω’∂’§÷Ä’∏÷Ç’¥ ’•’∂÷Ñ ’¥’∏÷Ç’ø÷Ñ’°’£÷Ä’•’¨ ’Å’•÷Ä ’∏÷Ç’¶’°’Æ ’°’¥’Ω’°’©’´’æ’® (÷Ö÷Ä‚Ä§ 25.08.2025):")
        return ENTER_INFO
    elif method == "time":
        await query.edit_message_text("‘Ω’∂’§÷Ä’∏÷Ç’¥ ’•’∂÷Ñ ’¥’∏÷Ç’ø÷Ñ’°’£÷Ä’•’¨ ’∂’°’≠’®’∂’ø÷Ä’°’Æ ’™’°’¥’® (÷Ö÷Ä’´’∂’°’Ø’ù 09:30):")
        return ENTER_INFO

async def receive_search_input(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle the user input for date or time search."""
    user_input = update.message.text.strip()
    mode = context.user_data.get("search_mode")
    driver = context.user_data.get("driver")
    branch_val = context.user_data.get("department")
    exam_type = context.user_data.get("exam_type")
    if mode == "date":
        # Validate date format (expect DD.MM.YYYY)
        if not re.match(r"^\d{1,2}\.\d{1,2}\.\d{4}$", user_input):
            await update.message.reply_text("‘Ω’∂’§÷Ä’∏÷Ç’¥ ’•’∂÷Ñ ’¥’∏÷Ç’ø÷Ñ’°’£÷Ä’•’¨ ’°’¥’Ω’°’©’´’æ’® ’±’•÷Ç’°’π’°÷É’∏’æ ’ï’ï.–ê‘±.–ê‘±‘±‘± (÷Ö÷Ä’´’∂’°’Ø’ù 05.09.2025):")
            return ENTER_INFO
        search_value = user_input
    elif mode == "time":
        # Validate time format (expect HH:MM)
        if not re.match(r"^\d{1,2}:\d{2}$", user_input):
            await update.message.reply_text("‘Ω’∂’§÷Ä’∏÷Ç’¥ ’•’∂÷Ñ ’£÷Ä’•’¨ ’™’°’¥’® ÷Ü’∏÷Ä’¥’°’ø’∏’æ ‘∫‘∫:’ê’ê (÷Ö÷Ä’´’∂’°’Ø’ù 09:30):")
            return ENTER_INFO
        search_value = user_input
    else:
        # Unexpected mode
        await update.message.reply_text("’è’•’≤’´ ’ß ’∏÷Ç’∂’•÷Å’•’¨ ’Ω’≠’°’¨÷â ’ì’∏÷Ä’±’•÷Ñ ’∂’∏÷Ä’´÷Å /start ’Ω’Ø’Ω’•’¨÷â")
        if driver:
            driver.quit()
        return ConversationHandler.END
    # Notify user of search start (typing action)
    await update.message.reply_text("‚è≥ ’ì’∂’ø÷Ä’∏÷Ç’¥ ’•’∂÷Ñ ’∞’°’Ω’°’∂’•’¨’´ ’ø’æ’µ’°’¨’∂’•÷Ä, ’≠’∂’§÷Ä’∏÷Ç’¥ ’•’∂÷Ñ ’Ω’∫’°’Ω’•’¨...")
    # Perform the search in background thread
    try:
        result_text = await asyncio.get_running_loop().run_in_executor(
            None, scraper.search_slots, driver, branch_val, exam_type, mode, search_value
        )
    except Exception as e:
        logger.error(f"Error searching slots ({mode}={search_value}): {e}")
        result_text = "’Ü’•÷Ä’∏’≤’∏÷Ç’©’µ’∏÷Ç’∂, ’∏÷Ä’∏’∂’∏÷Ç’¥’® ’π’∞’°’ª’∏’≤’æ’•÷Å÷â ’ì’∏÷Ä’±’•÷Ñ ’Ø÷Ä’Ø’´’∂÷â"
    # Send the result
    await update.message.reply_text(result_text)
    # Cleanup driver
    if driver:
        driver.quit()
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Cancel the conversation."""
    await update.message.reply_text("‘≥’∏÷Ä’Æ’∏’≤’∏÷Ç’©’µ’∏÷Ç’∂’® ’π’•’≤’°÷Ä’Ø’æ’°’Æ ’ß÷â ‘≤’°÷Ä’´ ÷Ö÷Ä ’¥’°’≤’©’•÷Ñ!")
    # Cleanup if driver exists
    driver = context.user_data.get("driver")
    if driver:
        driver.quit()
    return ConversationHandler.END

def main() -> None:
    # Initialize bot application
    app = Application.builder().token(config.TELEGRAM_TOKEN).build()
    # Set up conversation handler with the defined states and handlers
    conv_handler = ConversationHandler(
        entry_points=[CommandHandler("start", start)],
        states={
            SELECT_PHONE: [MessageHandler(filters.CONTACT | filters.TEXT, receive_phone)],
            ENTER_CODE: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_code)],
            SELECT_DEPT: [CallbackQueryHandler(choose_department, pattern="^dept:")],
            SELECT_EXAM: [CallbackQueryHandler(choose_exam_type, pattern="^(theoretical|practical)$")],
            SELECT_SEARCH: [CallbackQueryHandler(choose_search_method, pattern="^(day|date|time)$")],
            ENTER_INFO: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_search_input)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
        allow_reentry=True
    )
    app.add_handler(conv_handler)
    # Start polling the Telegram API
    app.run_polling()
    
if __name__ == "__main__":
    main()
